# A2A Protocol Specification v0.3.0 - Knowledge Base

This document is an LLM-optimized version of the A2A (Agent-to-Agent) Protocol specification for semantic search and retrieval.

## 1. Overview

The Agent2Agent (A2A) Protocol is an open standard for communication between independent AI agent systems. It enables agents built with different frameworks, languages, or vendors to interoperate.

### Key Goals
- **Interoperability**: Bridge communication between disparate agentic systems
- **Collaboration**: Enable agents to delegate tasks and exchange context
- **Discovery**: Allow agents to dynamically find and understand each other's capabilities
- **Flexibility**: Support sync request/response, streaming, and async push notifications
- **Security**: Enterprise-ready with standard web security practices
- **Asynchronicity**: Native support for long-running tasks and human-in-the-loop

### Guiding Principles
- **Simple**: Reuses HTTP, JSON-RPC 2.0, Server-Sent Events
- **Enterprise Ready**: Addresses auth, security, privacy, tracing, monitoring
- **Async First**: Designed for long-running tasks
- **Modality Agnostic**: Supports text, audio/video, structured data, embedded UI
- **Opaque Execution**: Agents collaborate without sharing internal state

## 2. Core Concepts

### A2A Client
An application or agent that initiates requests to an A2A Server on behalf of a user or another system.

### A2A Server (Remote Agent)
An agent or agentic system that exposes an A2A-compliant HTTP endpoint, processing tasks and providing responses.

### Agent Card
A JSON metadata document published by an A2A Server describing:
- Identity and capabilities
- Skills offered
- Service endpoint URL
- Authentication requirements

### Message
A communication turn between client and agent with:
- `role`: "user" or "agent"
- `parts`: One or more content Parts

### Task
The fundamental unit of work in A2A:
- Identified by unique ID
- Stateful with defined lifecycle
- Terminal states: completed, canceled, rejected, failed

### Part
The smallest unit of content within a Message or Artifact:
- `TextPart`: Plain text content
- `FilePart`: File content (bytes or URI)
- `DataPart`: Structured JSON data

### Artifact
An output generated by the agent during a task (documents, images, structured data).

### Context
A server-generated identifier to group related tasks logically.

## 3. Transport Protocols

A2A supports multiple transport protocols over HTTP(S):

### JSON-RPC 2.0 Transport
- Primary data format using JSON-RPC 2.0
- Content-Type: `application/json`
- Method names: `{category}/{action}` (e.g., "message/send", "tasks/get")

### gRPC Transport
- Uses Protocol Buffers v3 for serialization
- Implements `A2AService` gRPC service
- Supports TLS encryption (gRPC over HTTP/2)

### HTTP+JSON/REST Transport
- Uses appropriate HTTP verbs (GET, POST, PUT, DELETE)
- URL patterns: `/v1/{resource}[/{id}][:{action}]`
- Content-Type: `application/json`

### Streaming (Server-Sent Events)
For real-time updates via SSE:
- Content-Type: `text/event-stream`
- Each `data` field contains a JSON-RPC Response

## 4. Authentication & Authorization

A2A relies on standard HTTP authentication:

### Authentication Flow
1. Client discovers requirements via `AgentCard.authentication`
2. Client obtains credentials out-of-band (OAuth, API keys, etc.)
3. Client includes credentials in HTTP headers (e.g., `Authorization: Bearer <token>`)

### Server Responsibilities
- MUST authenticate every request
- Use `401 Unauthorized` or `403 Forbidden` for failures
- Include `WWW-Authenticate` header with 401 responses

### In-Task Authentication
For secondary credential requirements:
- Transition task to `auth-required` state
- Provide details in `TaskStatus.message`
- Client obtains and provides credentials in subsequent request

## 5. Agent Card

### Discovery Mechanisms
- **Well-Known URI**: `https://{domain}/.well-known/agent-card.json`
- **Registries/Catalogs**: Curated agent directories
- **Direct Configuration**: Pre-configured URLs

### AgentCard Structure

```json
{
  "protocolVersion": "0.3.0",
  "name": "Agent Name",
  "description": "What the agent does",
  "url": "https://agent.example.com/a2a/v1",
  "preferredTransport": "JSONRPC",
  "version": "1.0.0",
  "capabilities": {
    "streaming": true,
    "pushNotifications": true,
    "stateTransitionHistory": false
  },
  "securitySchemes": {
    "bearer": {
      "type": "http",
      "scheme": "bearer"
    }
  },
  "security": [{"bearer": []}],
  "defaultInputModes": ["text/plain", "application/json"],
  "defaultOutputModes": ["text/plain", "application/json"],
  "skills": [
    {
      "id": "skill-id",
      "name": "Skill Name",
      "description": "What the skill does",
      "tags": ["tag1", "tag2"],
      "examples": ["Example prompt 1", "Example prompt 2"]
    }
  ]
}
```

### AgentCapabilities
- `streaming`: Supports SSE for streaming responses
- `pushNotifications`: Supports async task updates via webhooks
- `stateTransitionHistory`: Provides task state transition history

### AgentSkill
- `id`: Unique identifier
- `name`: Human-readable name
- `description`: Detailed description
- `tags`: Keywords for categorization
- `examples`: Example prompts/scenarios
- `inputModes`/`outputModes`: Supported MIME types

## 6. Task Lifecycle

### TaskState Values
- `submitted`: Task awaiting execution
- `working`: Agent actively processing
- `input-required`: Waiting for user input
- `completed`: Successfully finished (terminal)
- `canceled`: Canceled by user (terminal)
- `failed`: Error during execution (terminal)
- `rejected`: Agent declined task (terminal)
- `auth-required`: Needs additional authentication
- `unknown`: Indeterminate state

### Task Object
```json
{
  "id": "task-uuid",
  "contextId": "context-uuid",
  "status": {
    "state": "completed",
    "message": {...},
    "timestamp": "2024-01-01T00:00:00Z"
  },
  "history": [...],
  "artifacts": [...],
  "kind": "task"
}
```

## 7. Protocol Methods

### message/send
Send a message to initiate or continue an interaction.
- **Method**: POST
- **Params**: `MessageSendParams` with message and optional configuration
- **Response**: `Task` or `Message`

### message/stream
Send a message and subscribe to real-time SSE updates.
- **Requires**: `capabilities.streaming: true`
- **Response**: SSE stream of `SendStreamingMessageResponse`

### tasks/get
Retrieve current state of a task.
- **REST**: `GET /v1/tasks/{id}`
- **Response**: `Task`

### tasks/cancel
Request cancellation of an ongoing task.
- **REST**: `POST /v1/tasks/{id}:cancel`
- **Response**: `Task`

### tasks/resubscribe
Reconnect to SSE stream for ongoing task.
- **REST**: `POST /v1/tasks/{id}:subscribe`
- **Requires**: `capabilities.streaming: true`

### Push Notification Methods
- `tasks/pushNotificationConfig/set`: Configure webhook for task updates
- `tasks/pushNotificationConfig/get`: Get push notification config
- `tasks/pushNotificationConfig/list`: List all configs for a task
- `tasks/pushNotificationConfig/delete`: Remove a config

### agent/getAuthenticatedExtendedCard
Get detailed Agent Card after authentication.
- **REST**: `GET /v1/card`
- **Requires**: `supportsAuthenticatedExtendedCard: true`

## 8. Error Handling

### Standard JSON-RPC Errors
| Code | Meaning |
|------|---------|
| -32700 | Parse error (invalid JSON) |
| -32600 | Invalid Request |
| -32601 | Method not found |
| -32602 | Invalid params |
| -32603 | Internal error |

### A2A-Specific Errors
| Code | Name | Description |
|------|------|-------------|
| -32001 | TaskNotFoundError | Task ID doesn't exist |
| -32002 | TaskNotCancelableError | Task not in cancelable state |
| -32003 | PushNotificationNotSupportedError | Push notifications not enabled |
| -32004 | UnsupportedOperationError | Operation not supported |
| -32005 | ContentTypeNotSupportedError | MIME type not supported |
| -32006 | InvalidAgentResponseError | Agent generated invalid response |
| -32007 | AuthenticatedExtendedCardNotConfiguredError | No extended card configured |

## 9. Method Mapping Reference

| JSON-RPC | gRPC | REST |
|----------|------|------|
| message/send | SendMessage | POST /v1/message:send |
| message/stream | SendStreamingMessage | POST /v1/message:stream |
| tasks/get | GetTask | GET /v1/tasks/{id} |
| tasks/cancel | CancelTask | POST /v1/tasks/{id}:cancel |
| tasks/resubscribe | TaskSubscription | POST /v1/tasks/{id}:subscribe |
| tasks/pushNotificationConfig/set | CreateTaskPushNotification | POST /v1/tasks/{id}/pushNotificationConfigs |
| tasks/pushNotificationConfig/get | GetTaskPushNotification | GET /v1/tasks/{id}/pushNotificationConfigs/{configId} |
| agent/getAuthenticatedExtendedCard | GetAgentCard | GET /v1/card |

## 10. A2A vs MCP

**Model Context Protocol (MCP)**: Standardizes how AI agents connect to tools, APIs, and data sources. Defines how to describe tool capabilities and pass inputs/outputs.

**Agent2Agent Protocol (A2A)**: Standardizes how independent AI agents communicate and collaborate as peers. Handles discovery, negotiation, task management, and context exchange.

**How they work together**: An A2A Client requests an A2A Server to perform a task. The Server might use MCP to interact with underlying tools and APIs to fulfill that task.

## 11. Security Best Practices

- Always use HTTPS with TLS 1.3+ in production
- Validate TLS certificates
- Handle credentials securely (never in Agent Card plaintext)
- Implement least privilege authorization
- Validate webhook URLs to prevent SSRF
- Use appropriate authentication schemes (OAuth 2.0, API keys, mTLS)
